bank api - crud\

route table 
  bankcode, status, ip, port
route ws (crud)  
  
mac = hmac(amount+switchReference+reference+sourceAccount , secret);

LS Security
----
 each caller will need credentials
 request data encryption
 ip whitelisting - single,block
 api-keys will be used.
 credentials table for storing api-keys
 how can developer be prevented from seeing api-key = shd be set in env variable, in cfg. developer shd not have access to it.
 api-keys shd be generated by risk on the admin portal
 
create table ls_api_credentials
 api keys will be used
   X-API-Key = X-API-Key
   X-API-Secret = sha512(x-api-key.timestamp) . timestamp shd be 
   X-Nonce
   X-Timestamp
   
CREATE TABLE `nonce` (
  `nonce` varchar(255) NOT NULL,
  `api_key` varchar(45) NOT NULL,
  `created` timestamp NULL DEFAULT current_timestamp(),
  UNIQUE KEY `unq` (`nonce`,`api_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
    
	delete expired nonces
 
Admin generate LS credentias
Table to store LS credentials
Table - id, key, secret, requester, app, status, approver, created


1,234,567,890,123,456

 
Fees 
------
fee are sent by caller 
fee services to be developed

LS Flow
---
1. incoming request
2. security checks - authentication
3. generate mac, switch reference
4. call cms webservice(if it applies)
5. insert record (if it applies)
6. Add merchant data to request
7. route request - request data to route, format and security, see ecarddb.e_tmcnode;, (see efrontend ecarddb.interface table columns (active,allow_web), see ecarddb.e_tmckey for key exchange
8. save response (00 success, 31 failed, 06 failed)

LS Error Codes
----
 should we use ISO Error codes? maybe yes but with our customisations as well

Transaction Routing(Decision
------
-Routing is determined based on the Transcode and bank code of either the source or destination account
eg 1. If you pass Transcode Debit, the switch will only send request to debit without passing corresponding credit. In this example routing will based on the debit account and the Transcode.
So the two(debit account and Transcode) together will help do the routing

eg 2. If the Transcode was credit, the credit bankCode will be used to do the routing

eg 3. If the Transcode was FT (ie FT is a duplex transaction), routing will first be done to the debit bank code and then another routing to the credit bank code(ie if debit was successful)


Key discussion
*data encryption - AES CBC
*response json  { error, message, reference etc}


microservices flow
-----
1. request from api gateway
2. retrieve merchant data (merchant code, accountId and add to the header/body)
3. call fee service if it applies and set the fee
4. validate request ie check params if request is correct
5. if Elevy applies, confirm the elevy amount using the reference passed. same reference was used by merchant to get the elevy
6. Generate LS request, encrypt data
7. LS calls requires authorisaction ie set auth header in request
8. call LS


LS security  
---


transaction security
---
check digit - temporary block account if txn occurs within a period eg 1 sec interval and there are more than 1 request

implementation works/flow
--
db design and implementation ( 1 single table or two tables for insert request and insert response)
switch error codes
tables for duplex transactions
determination of json request - whether json object or json with nested objec
ls momo engine

04062023
1. ls txn tables - 2 tables to be used. 1.trans_req_log, transaction
2. 


error codes to use, error codes mapping table
see ecardb.e_reversal table
method markReversed(reference) = updates columns to reversal status. 


risk checks
-
check digit
log suspicious or profiled txns